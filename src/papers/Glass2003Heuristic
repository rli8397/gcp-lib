package papers;

import java.util.*;

import general.Heuristic;
import general.Instance;

public class Glass2003Heuristic extends Heuristic {
    private Glass2003Heuristic[] population;

    public Glass2003Heuristic(Instance instance, double runtime, int popSize) {
        super(instance, runtime);
        k = instance.getMaxChromatic();

        Glass2003Heuristic solution;
        InitPopulation(popSize);

        do {
            // chooses 2 random parents
            int s1 = this.random(population.length);
            int s2 = this.random(population.length);

            while (s2 == s1) {
                s2 = this.random(population.length);
            }

            solution = crossOver(population[s1], population[s2]);
            solution.vertexDescent();

            // if a valid solution is found, we will restart the algorithm looking for k - 1
            // colors
            if (solution.objective == 0) {
                solution.reduceK();
                InitPopulation(popSize);
            } else {
                // updatePopulation
                int toReplace = s1;
                if (population[s1].getObjective() < population[s2].getObjective()) {
                    toReplace = s2;
                }
                population[toReplace] = solution;
            }

        } while (report(solution));
    }

    public void InitPopulation(int popSize) {
        this.population = new Glass2003Solution[popSize];
        for (int i = 0; i < popSize; i++) {
            population[i] = new Glass2003Solution(this, k);
            population[i].greedyConstruction();
        }
    }
    
    public Glass2003Solution crossover(Glass2003Solution s1, Glass2003Solution s2){

        Garlinier1999Solution combined = new Garlinier1999Solution(this, this.k);
        for (int l = 1; l <= k; l++) {
            if (l % 2 == 1) {
                s1.calcMaxCardinalityClass();
                int color = s1.maxCardinalityClass;
                for (int i = 0; i < instance.getNumNodes(); i++) {
                    if (s1.coloring[i] == color) {
                        s1.coloring[i] = -1;
                        s2.coloring[i] = -1;
                        combined.coloring[i] = l;
                    }
                }
            } else {
                s2.calcMaxCardinalityClass();
                int color = s2.maxCardinalityClass;
                for (int i = 0; i < instance.getNumNodes(); i++) {
                    if (s2.coloring[i] == color) {
                        s1.coloring[i] = -1;
                        s2.coloring[i] = -1;
                        combined.coloring[i] = l;
                    }
                }
            }
        }

        // if there are leftover nodes, just randomly assign them
        for (int i = 0; i < instance.getNumNodes(); i++) {
            if (combined.coloring[i] <= 0) {
                combined.coloring[i] = this.random(instance.getNumNodes());
            }
        }

        return combined;
    }

    //Linear Assignment into Uniform Crossover 
    public Glass2003Solution permutationsymmetrycrossover(Glass2003Solution s1, Glass2003Solution s2) {
        
        
    }

    public class Glass2003Solution extends SolutionConflictCounts{
        private int[][] costMatrix;
        
        public Glass2003Solution(Heuristic heuristic, int colors) {
            this.heuristic = heuristic;
            this.instance = heuristic.getInstance();
            this.k = colors;
            this.objective = 0;
            this.coloring = new int[instance.getNumNodes()];
            costMatrix = new int [numNodes][k + 1];
            
        }

        public void vertexDescent() {

            int numNodes = instance.getNumNodes();
            int[][] costMatrix = new int[numNodes][k]

            
            //Best color List Structure for each vertex
            List<Integer>[] bestColorList = new List<Integer>[numNodes];

            // Initialize cost matrix and best color list
            for (int i = 0; i < numNodes; i++) {
                bestColorList[i] = new ArrayList<>();

                //Compute Cost of each Vertex if Moved to different color
                for (int c = 1; c <= k; c++) {
                    costMatrix[i][c] = computeCost(i, c);
                }
                updateBestColorList(i, costMatrix, bestColorList);
            }

            boolean changed = true;

            //Cycles until no changes can be made
            while (changed) {
                changed = false;
                for (int i = 0; i < numNodes; i++) {
                    int currentColor = coloring[i];
                    List<Integer> bestColors = bestColorList[i];

                    if (!bestColors.contains(currentColor)) {
                        int newColor = bestColors.get(heuristic.random(bestColors.size()));
                        coloring[i] = newColor;
                        changed = true;

                        // Update cost matrix and bestColorList for neighbors
                        for (int neighbor : instance.getAdjacent(i)) {
                            for (int c = 1; c <= k; c++) {
                                costMatrix[neighbor][c] = computeCost(neighbor, c);
                            }
                            updateBestColorList(neighbor, costMatrix, bestColorList);
                        }

                        // Update own row too
                        for (int c = 1; c <= k; c++) {
                            costMatrix[i][c] = computeCost(i, c);
                        }
                        updateBestColorList(i, costMatrix, bestColorList);
                    }
                }
            }

            // Finally update the objective and conflict counters
            calcObjective();
        } 

        //Computes Cost of each move
        private int computeCost(int vertex, int color) {
            int cost = 0;
            for (int neighbor : instance.getAdjacent(vertex)) {
                if (coloring[neighbor] == color) {
                    cost++;
                }
            }
            return cost;
        }

        //Updates the best color list after a descent is made
        private void updateBestColorList(int vertex, int[][] costMatrix, List<Integer>[] bestColorList) {
            int minCost = Integer.MAX_VALUE;
            bestColorList[vertex].clear();
            for (int c = 1; c <= k; c++) {
                int cost = costMatrix[vertex][c];
                if (cost < minCost) {
                    minCost = cost;
                    bestColorList[vertex].clear();
                    bestColorList[vertex].add(c);
                } else if (cost == minCost) {
                    bestColorList[vertex].add(c);
                }
            }
        }

        

        public void calcMaxCardinalityClass() {
            int[] counts = new int[this.k];
            int maxCardinality = -1;
            for (int i = 0; i < instance.getNumNodes(); i++) {
                if (this.coloring[i] > 0) {
                    counts[this.coloring[i]]++;
                    if (counts[this.coloring[i]] > maxCardinality) {
                        maxCardinality = counts[this.coloring[i]];
                        maxCardinalityClass = this.coloring[i];
                    }
                }
            }
        }

    }


}